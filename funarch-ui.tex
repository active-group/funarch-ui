\documentclass[sigplan,screen]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[FUNARCH '25]{The Third ACM SIGPLAN Workshop on Functional Software Architecture -- FP in the Large}{October 17,
  2025}{Singapore}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Evolution of Functional UI Paradigms}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Markus Schlegel}
\email{markus.schlegel@active-group.de}
\affiliation{%
  \institution{Active Group GmbH}
  \streetaddress{Hechinger Straße 12/1}
  \city{Tübingen}
  \country{Germany}
  \postcode{72072}
}

\author{Michael Sperber}
\email{michael.sperber@active-group.de}
\affiliation{%
  \institution{Active Group GmbH}
  \streetaddress{Hechinger Straße 12/1}
  \city{Tübingen}
  \country{Germany}
  \postcode{72072}
}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Functional paradigms for user-interface (UI) programming have
  undergone significant evolution over the years, from early
  stream-based approaches, monad-based toolkits mimicking OO practice
  to modern model-view-update frameworks.  Changing from the
  inherently imperative classic Model-View-Controller pattern to
  functional approaches has significant architectural impact,
  drastically reducing coupling and improving maintainability and
  testability.  On the other hand, achieving good modularity with
  functional approaches is an ongoing challenge.  This paper traces
  the evolution of functional UI toolkits along with the architectural
  implications of their designs, summarizes the current state of the
  art and discusses remaining issues.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10010520.10010521</concept_id>
       <concept_desc>Computer systems organization~Architectures</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10010940.10010971.10010972</concept_id>
       <concept_desc>Software and its engineering~Software architectures</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
       <concept_desc>Software and its engineering~Functional languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011006.10011008.10011009.10011012</concept_id>
       <concept_desc>Software and its engineering~Functional languages</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
    <concept>
        <concept_id>10011007.10011006.10011066</concept_id>
        <concept_desc>Software and its engineering~Development frameworks and environments</concept_desc>
        <concept_significance>500</concept_significance>
    </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Architectures}
\ccsdesc[500]{Software and its engineering~Software architectures}
\ccsdesc[500]{Software and its engineering~Functional languages}
\ccsdesc[500]{Software and its engineering~Development frameworks and environments}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{functional programming, software architecture, patterns,
  graphical user interfaces}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
\received{16 June 2025}

\maketitle

Implementing applications with graphical user interfaces (GUI) remains
a challenge, and the architecture of these applications and the UI
toolkits they use is still evolving.  This is surprising, as the basic
tenet of GUI architecture---the Model/View separation---has remained
unchanged for almost 50 years now.

Starting with the \textit{Movel-View-Controller} pattern
(MVC)~\cite{MVC} and its implementation in the 1970s, the software
industry and research community have produced a plethora of \textit{UI
  toolkits}, libraries that provide the conceptual elements of a
UI---text, input fields, buttons, lists, menus, grids and more---as
objects to be created and manipulated by the program, and henceforth
called \textit{widgets}.  Each toolkit dictates or at least
constraints the organization of the applications that use them.

This paper examines the evolution of UI toolkits and the resulting
application architecture since their inception from a functional
perspective.

\paragraph{Overview} Section~\ref{sec:ui-and-architecture} summarizes
the software-architectural concepts relevant for the discussion in
this paper.  Section~\ref{sec:mvc} reviews the Model-View-Controller
pattern, the starting the point for all modern UI toolkits.
Section~\ref{sec:event-loop} discusses the event loop, and
implementation aspect of many UI toolkits, along with its
architectural implications.  Section~\ref{sec:functional-ui} reviews
early functional UI toolkits.  Section~\ref{sec:universe-teachpack}
describes a transition point between these early toolkits and the
toolkits of the modern era---Racket's Universe teachpack.
Section~\ref{sec:elm-react} discusses Elm and React, two
implementations of the functional Model-View-Update pattern.
Section~\ref{sec:ui-toolkits-elsewhere} briefly reviews modern
object-oriented toolkits for comparison.  The Model-View-Update
pattern still struggles with modularity issues described in
Section~\ref{sec:modularity-challenges}.  Section~\ref{sec:reacl}
describes the Reacl toolkit, designed to tackle these issues at a
technical level.  Section~\ref{sec:persistent-pains} explains why UI
programming remains a struggle despite all the technical progress, and
Section~\ref{sec:reacl-c} describes the architectural approach that we
have developed to deal with it.  Section~\ref{sec:conclusion} concludes.


\section{UI and Software Architecture}
\label{sec:ui-and-architecture}

The job of a UI toolkit is to enable developers to create and maintain
UI applications.  These dual requirements---fast creation and
effective maintenance---tend to be in conflict.  The initial version
of a software system as quickly and cheaply as possible often produces
code that is expensive to maintain.  This is especially pernicious in
practice, as most the of the cost produced by a software system is in
maintenance, not initial creation~\cite{GreenBook}.

This phenomenon seems to be especially pronounced in GUI applications:
The Visual Basic 6 (VB6) environment for building such
applications~\cite{VB6} was optimized for fast initial creation, and
as such one of the most successful such environments of all time.
Microsoft relegated VB6 to ``legacy'' status in 2008: Despite this,
many VB6 applications are still around at the time of writing, even
though their further development is painful and costly and their
maintainers understand the importance of moving away from an
unsupported platform.

Moving away from VB6 is so difficult because a VB6 application
typically combines UI-related code, domain logic, and possible
interactions with a database and storage in the same function, making it
all but impossible to replace any of these parts of the system
independently.  This \textit{coupling} between the UI, the domain
logic, and the storage logic prevents piecewise migration to a
supported environment, making a ``big-bang migration'' the only
feasible path away from VB6.  Big-bang migration is usually ecomically
infeasible, and thus these projects are stuck.

The problem of these VB6 projects and many other projects that run
into high maintenance costs is \textit{coupling}~\cite{GreenBook},
dependencies between different conceptual building blocks of the
software. Coupling dependencies cause changes in one place to be require changes in
other places.  Consequently, the central concern of software
architecture is to enable effective long-term maintenance by keeping
coupling down.  A software project can control coupling through its
strategy for \textit{modularization}~\cite{Modularity}---splitting the
project into building blocks and maintaining strong boundaries between
them by establishing explicit interfaces.

The shared concern of UI applications is to establish modularity
between the UI code and the domain logic.  Reenskaug's goal with the
MVC pattern was to enable a particular kind of change---changing or
replacing the UI without changing the domain logic, even having
multiple UIs without the rest of the application being affected.  To
that end, the central innovation of MVC was the decoupling of UI code
(``view'') from the domain logic (``model'').

The decoupling between view and model also has other practical
implications for developers who want to implement automatic tests for
as much of their code as possible.  With environments that strongly
couple view and model, such as VB6, applications are difficult to
test, because the only way of invoking domain functionality is via the
UI, which is intended for human operators.  Often, the only resort in
these cases is to simulate an operator programmatically, which is
expensive and brittle.

For the rest of this paper, we will examine UI toolkits and paradigms
with respect to these tenets of software architecture: How do they
impact coupling, modularity, and thus maintainability?  

% state seems intrinsic

\section{Model-View-Controller}
\label{sec:mvc}
  
% http://bildungsgueter.de/Smalltalk/Pages/MVCTutorial/Pages/FS0004.htm

MVC is the ancestor of most contemporary UI
paradigms and frameworks.  The separation of the model from the view
is universally beneficial from an architectural standpoint.
Developers can change the UI and replace the UI toolkit without
changing the model.  Moreover, since the model can function without
the UI, testing automation is significantly easier compared to a
tightly coupled view.

MVC programs need to keep the view current when the state of the model
changes.  To that end, models typically implement a variation of the
\textit{observer pattern}~\cite{GoF}: The model maintains a list of
``dependents,'' i.e.\ objects that it notifies on changes by calling
an \texttt{update:} method.  (The controller is tightly coupled to the
view, and its role is unimportant for this discussion.)

As the \texttt{update:} method informs the view of state changes, this
approach is inherently imperative.  MVC has nice modularity
properties, as each part of the model only needs to be coupled to
``its'' part of the view, and composition is easy.
It also creates several challenges to
software architects:
\label{sec:challenges}
%
\begin{enumerate}
\item Keeping the view current with respect for the model involves two
  tasks: initially \emph{constructing} the view by creating the
  various UI widgets, and later \emph{mutating} the view upon calls to
  \texttt{update:}  Conceptually, the result of mutating the view
  should be the same as re-constructing the view, but the concrete
  code for both is quite different, implementing the same logic twice.
\item To achieve modularity, architects should be able to split a large,
  complex view into loosely coupled subviews.  This raises the
  question of how big those subviews should be. Making them large and
  correspondingly having them represent a largher chunk of the model
  simplifies the change logic, as it requires fewer implementations of
  \texttt{update:} However it also increases coupling between model
  and view.  Moreover, it causes potential performance issues when the
  typical change is only to a small part of the model and only needs a
  small part of the view to change: In that case, \texttt{update:}
  either spends time drilling down to this small part of the view or
  changing larger parts of the view than necessary.
\item The view is not just a passive display, but will typically
  include interactive elements that cause changes in the model.
  Naively implemented, these changes indirectly trigger calls to
  \texttt{update:} in the view, which again might spill over into
  changes, causing a cyclic call chain.
\end{enumerate}
%
Consider the following practical example:
%
% weather composite, air pressure, temperature controls

\begin{figure}[tb]
\begin{verbatim}
class Weather(field pressure: Pressure,
              field temperature: Temperature) {
  ...
}

interface Observer {
  method update(info)
}

class Model {
  var observers: List Observer

  method changed(info) {
    for each sobserver in self.observers
      observer.update(info)

  method subscribe(observer) {
    observers += observer
  }
}

class Pressure extends Model {
  var hPa: double
  method setHPa(newHPa: double) {
    self.hPA = newHPa
    self.changed(newHPA)
  }
}

class Temperature extends Model {
  var kelvin: double
  method setKelvin(newKelvin: double) {
    self.kelvin = newKelvin
    self.changed(newKelvin)
  }
}
\end{verbatim}
  \caption{Model for weather data}
  \label{fig:weather-model}
\end{figure}

\begin{figure}[tb]
\begin{verbatim}
class TemperatureView
  (field temperatureModel: Temperature):
{
  var textField =
    new TextField(toText(temperatureModel.kelvin) + "K")

  temperatureModel.subscribe(self)

  method update(newKelvin) {
    textField.setText(toText(newKelvin) + "K")
  }
}

class PressureView
  (field pressureModel: Pressure)
{
  var textField =
    new TextField(toText(pressureModel.hPa) + "hPa")

  pressureModel.subscribe(self)

  method update(newHPa) {
    textField.setText(toText(newKelvin) + "hPa")
  }
}

class WeatherView(field weatherModel: Weather) {
  var temperatureView =
    new TemperatureView(weatherModel.temperature)
  var pressureView =
    new PressureView(weatherModel.pressure)
  ...
}
\end{verbatim}
  \caption{View for weather data}
  \label{fig:weather-view}
\end{figure}
%
Figure~\ref{fig:weather-model} shows object-oriented pseudcode for a
weather model that contains air pressure and temperature, each with
its own encapsulated state.  Figure~\ref{fig:weather-view} shows
skeleton code for a view that displays both in text fields.  The code
demonstrates nicely the modularity of the approach, as
\texttt{PressureView} and \texttt{TemperatureView} each subscribe to
their respective models, with no coordination required from
\texttt{WeatherView}.

The example also illustrates the first two challenges explained above:
%
\begin{enumerate}
\item The code for constructing the string representing the pressure
  and temperature is duplicated between the code that constructs the
  text field and the code that updates it.  It is possible to abstract
  out some code, but the fundamental separation between construction
  and update---which have to be consistent---remains.
\item The code contains two sub-views, updated separately.
  Alternatively, the subscription and update could happen between
  \texttt{WeatherView} and \texttt{Weather}, reducing modularity
  somewhat but also reducing the amount of code required.
\end{enumerate}
%
Note that the views are missing code to unsubscribe them from their
respective models---this further complicates the interaction between
model and view.

\begin{figure}[tb]
\begin{verbatim}
class TemperatureView2
  (field temperatureModel: Temperature) {
  var celsiusView =
    new TextField
      (toText(kToC(temperatureModel.kelvin)))
  var fahrenheitView =
    new TextField
      (toText(kToF(temperatureModel.kelvin)))

  temperatureModel.subscribe(new Observer {
      method update(newKelvin) {
        celsiusView.setText(toText(kToC(newKelvin)))
    }
  })
  temperatureModel.subscribe(new Observer {
      method update(newKelvin) {
        textField.setText(toText(kToC(newKelvin)))
    }
  })
  celsiusView.subscribe(new Observer {
     method update(...) {
      temperatureModel.setKelvin(cToK(...))
     }
  })
  fahrenheitView.subscribe(new Observer {
     method update(...) {
      temperatureModel.setKelvin(fToK(...))
     }
  })
}
\end{verbatim}
  %
  \caption{Two different sub-views on the same model}
  \label{fig:temperature-view2}
\end{figure}
%
Figure~\ref{fig:temperature-view2} shows a different view, just on the
temperature, but with two sub-views showing the temperature with
different units.  The code also adds the element of interactivity:
When the user interacts with the view, the two observers attached to
the views update the model.  This demonstrates the third challenge
described above: There is now an update loop between the model and
the two views: Each update to the model updates the view, which
updates the model, and so on.  The code could break the loop by
checking whether the new value is different from the old before
calling \texttt{changed}, but this is brittle---especially as
floating-point rounding is involved in the conversion between the
three units.

\section{The Curse of the Event Loop}
\label{sec:event-loop}

MVC UI toolkit also face a recurring implementation challenge: While a
MVC program constructs the UI in terms of hierarchically organized
views, it must display the UI as a flat panel of pixels.  This means
that technically users interact with the UI panel as a whole, and the
UI toolkit must infer the specific sub-view that is the target of the interactions.
Consider for example a button, which the user presses by clicking with
a mouse: The UI toolkit must infer from the position of the mouse
cursor the particular button view at those coordinates, and cause its
subscribers to be notified.

UI toolkits have traditionally chosen to implement this process using
an \textit{event loop}, a piece of code that receives hardware input
events and calls subscriber callback of the corresponding
views.  This happens repeatedly \textit{ad infinitum}, hence the
``loop''.  Here is pseudocode for a typical event loop:
%
\begin{verbatim}
while (true) {
  var event = get_input_event()
  dispatch_event(event)
}
\end{verbatim}
%
For this to work in practice, the \textit{update} methods of the view
subscribers must not block, as this would prevent further user
interaction.  If an \textit{update} method needs to perform I/O or
other blocking operations, this restriction effectively inverts the
flow of control: The method must start the operation asynchronously
and register it with the event loop, to be notified when the operation
has completed.  This is often awkward---more so, when the event loop
of a particular UI toolkit only supports a limited set of such
operations, as is common.

In principle, UI programs could also just start threads that perform
blocking operations synchronously, but interact with the UI
asynchronously.  However, many UI toolkits insist on their functions
being called from the thread the UI toolkit runs in, further
complicating matters.

Thus, typical MVC UI toolkits couple the control flow of the
central event loop to the control flow of the subscriber callbacks,
which includes the code that manipulates the model.  The restrictions
resulting from this coupling often force developers to write these
callbacks and their dependencies in a non-linear arrangements,
creating a style of programming colloquially known as \textit{callback
  hell}.

\section{Functional UI Toolkits: The Early Days}
\label{sec:functional-ui}

This section briefly describes some early UI tookits for functional
languages.  We focus on toolkitts that implemented genuinely
functional ideas.  Many other UI toolkits for functional languages
basically provided bindings for underlying C/C++ libraries and thus
inherited its imperative MVC pattern.

\subsection{eXene}

The eXene~\cite{eXene} toolkit was developed as part of the Concurrent
ML project~\cite{ConcurrentML} (CML).  CML is a combinator library in
Standard ML for arbitrarily assembling communication events.  EXene
uses Concurrent ML to solve the event-loop problem described in
Section~\ref{sec:event-loop}.  In eXene, the global event loop is
relegated to the background in favor of individual event loops running
in threads, each associated with a particular UI widget.  Rather than calling
subscriber methods directly, the event loop sends asynchronous
messages to the widget event loops.  This decouples the control flow
of the central event loop from that of its components.  Implementors
of components are afforded great flexibility in orchestrating their
actions through CML's event combinators.

While CML and eXene originated in the context of functional
programming, and CML's combinators rely on higher-order functions to
some extent, the overall approach of UI manipulation in eXene remains
firmly imperative.  Thus, eXene inherits challenge \#1 from Section~\ref{sec:challenges}.

\subsection{Fudgets}

While eXene's Standard ML is (also) an imperative language, Haskell is pure.
Haskell's lazy evaluation makes just adding functions that ``do
stuff'' impractical.  Consequently, interacting with the outside world
was generally a challenge for the designers of Haskell during its
nascency in the 1990s.  This also affects the designers of UI
libraries who were motivated to specify UIs in terms of pure
functions.  A notable early attempt to do this was the
\textit{Fudgets} toolkit~\cite{Fudgets}.  (At the time of writing,
Fudgets is still being maintained as a Haskell library.)

Fudgets represents a UI component (a \textit{fudget}) as a
\textit{stream processor} of type \verb|F a b| that transforms a
stream of input values of type \texttt{a} into output values of type
\texttt{b}.  Fudgets can be combined into sums and products, building
UI structure and reactivity in a hierarchical fashion.  Fudgets
completely abstracts the event-loop paradigm away from the user
program, which consists exclusively of pure functions.

The view of fudgets as attaching pure functions to laid-out UI
components implies that the structure of the fudgets is static.  UIs
frequently need to have dynamic structure, however---for example, when
displaying a list of UI items that supports adding and removing
elements.  Fudgets addresses this by combinators that accept special
command values that describe mutations of the UI structure,
effectively sneaking in imperative elements in its otherwise pure
model.  Thus, Fudgets also partially inherits challenge \#1 from
Section~\ref{sec:challenges}.

\subsection{Fruit}

Fruit~\cite{Fruit} re-imagines the basic idea of Fudgets on top of the
idea of Functional-Reactive Programming~\cite{FRP}, which had been
developed in the meantime.  Fruit retains the purity and
compositionality of Fudgets,  replacing the stream processors of
Fudgets with FRP signal transformers.  There are two notable
differences between Fudget and Fruit, however:
\begin{itemize}
\item Fudgets widgets have implicit access to interactive events,
  while Fruit requires them to be threaded explicitly through the
  program.  This means that a Fruit program is coupled to all aspects
  of the ``outside world'' it interacts with, making it difficult to
  add interactions outside the UI (such as file or network I/O) after
  the fact.
\item Another difference concerns dealing with dynamic UI components:
  Whereas Fudget views by default display the values coming from a
  stream (and are thus ``outside'' those streams), Fruit has the views
  themselves be the values of the FRP signals, and dynamic structure
  can be expressed by just having new values return a different view.
\end{itemize}
%
Thus, Fruit avoids challenge \#1 from Section~\ref{sec:challenges},
but comes with its own modularity problem.

\subsection{Haggis}

Haggis was a short-lived UI toolkit for GHC~\cite{Haggis}, which took
somewhat of middle path between eXene and Fudgets: While Fudgets
provides a purely functional UI for constructing widgets via explicit
combinators, Haggis provides an imperative UI running in the
\texttt{IO} monad for this construction.  Haggis deals with the event
loop similarly to eXene, replacing Concurrent ML with Concurrent
Haskell.  For the reactive part of a UI widget, Haggis provides a
handle separate from the view part.  The program can wait for
interaction on these handles also in the \texttt{IO} monad (in
separate threads if that is convenient), and allows combining them in
a way similar to CML events.  Thus, Haggis also inherits challenge
\#1 from Section~\ref{sec:challenges}.

\section{The Racket Universe Teachpack}
\label{sec:universe-teachpack}

Teachers of introductory programming courses would often like to
enable their students to write interactive programs.  The complexity
of UI toolkits have traditionally made this difficult, at least in the
era of toolkits described in the previous section.  The Racket system
since 2003 has come with a library called the \textit{Universe teachpack} for an
introductory course~\cite{UniverseTeachpack} that allows writing
distributed, interactive video games in a purely functional manner.

The Universe teachpack is basically ``half'' a UI toolkit.  It is an
interesting subject for study, as it does address the pernicious
challenge \#1 of the UI toolkits described above: The duplication of
view logic between initial construction and later update.  We focus
here on the ``world'' part of the Universe teachpack, i.e.\ video
games without distribution.  To implement such a video game, the
developer only has to implement a small number of pure functions, all
of which operate on a model called the ``world state,'' represented by
a single value of type \texttt{WorldSt}, which is entirely under the
control of the program:
%
\begin{verbatim}
on-draw : WorldSt → Image
on-tick :  WorldSt → WorldSt
on-key :  WorldSt KeyEvt → WorldSt
on-mouse : WorldSt Nat Nat MouseEvt → WorldSt
\end{verbatim}
%
These functions are all callbacks for the Universe teachpack, the
programs contains no explicit calls to them.

The \texttt{on-draw} function handles view construction and uses Racket's
\texttt{image} teachpack to build a single frame of the video game.
(The \texttt{image} teachpack is a combinator library in the style of
Henderson's functional geometry~\cite{Henderson1982}.)  There is no
separate function for view \emph{update}: Whenever the model
transitions to a new state, the Universe teachpack simply calls
\texttt{on-draw} again and redraws the \emph{entire} frame.  This is
fast enough in practice to achieve reasonably fluid animation.

The other functions provide reactivity to different kinds of events:
All of them take a \texttt{WorldSt} state as input and output a new
state, which the teachpack feeds into \texttt{on-draw}.
\texttt{On-tick} is called on every clock tick to provide movement
even when there is no user interaction.  \texttt{On-key} is called on
key presses, and \texttt{on-mouse} on mouse events.  Writing these
functions is well within the purview of introductory-course students.

Consequently, the Universe teachpack uses a ``brute-force'' approach
to the view-update poblem: Use a single monolithic value for the model
state, and redraw everything every time the model moves to a new
state.  This means no separate view-update code---challenge \#1
solved.

Unfortunately, this approach also abandons the good modularity
properties of object-oriented MVC toolkits: From the point of view of
the UI toolkit, the model state is a single value, and there is no
simple way to split it---and the corresponding view elements---into
sub-views while retaining a similarly simple API.  Thus, the Universe
teachpack faces the sub-view challenge \#2 from
Section~\ref{sec:challenges}.  This is not a
problem in this context: The video games realistically implemented in
a class  are simple enough that unified state is appropriate.  However,
it does prevent easily scaling the approach to realistic UIs in a
modular fashion.

% FIXME: Conal's UI paper
% http://conal.net/papers/Eros/
% PureScript/Halogen

\section{The Evolution of Elm and React}
\label{sec:elm-react}

Elm~\cite{Elm} is a UI toolkit and companion Haskell-like language
that translates to JavaScript and thus allows implementing web
applications.  Elm is in production use in quite a few open-source and
commercial projects.  Elm's initial release in 2012 was based on FRP Signals,
and was similar to Fruit.  Its innovation was its support for
asynchronous I/O, which is a problem for Fruit because of its global
approach to I/O.

Elm evolved to an approach different from that of its inception,
leaving its FRP legacy behind in 2016~\cite{ElmFarewellFRP}.  This approach
gives rise to an alternative UI pattern called
\textit{Model-View-Update}.  An Elm program mostly consists of only
two pure functions operating on values of a type \texttt{Model},
defined by the UI program:
%
\begin{verbatim}
view : Model -> Html Msg
update : Msg -> Model -> (Model, Cmd Msg)
\end{verbatim}
%
\begin{figure}
  \centering
  \includegraphics[width=\columnwidth]{model-view-update}
  \caption{The Model-View-Update pattern}
  \label{fig:mvu}
\end{figure}
%
Figure~\ref{fig:mvu} illustrates the pattern.
The \texttt{view} function constructs the UI, represented as a HTML
tree.  Each interactive UI widget carries a message of the
\texttt{Msg} type (also defined by the UI program) that is generated
when the user interacts with the widget.  The Elm toolkit then passes
this message to the \texttt{update} function that generates a new
model, which again gets fed into \texttt{view} and so on.  (The
\texttt{Cmd} type allows triggering impure actions outside of user
interactions.)

The View-Model-Update model is extraordinarily simple and easy to
learn, as it does not require the developer to know any higher-level
abstractions like signals, stream transformers or monads.  It also
completely avoids the circular dependency between view and model.

The idea of Model-View-Update is quite similar to that of Racket's
Universe teachpack: The view is re-constructed after every user
interaction, and it uses a single, monolithic value for the model
state.\footnote{Elm does not re-draw the entire UI on a call to the
  update function, but instead compares the output of the view
  function with the previous output, updating the DOM only for
  differences between the two.}  The possible messages belong to a
single central type.

Consequently, Elm also inherits the Universe teachpack's architectural
trade-offs: It solves challenge \#1 from Section~\ref{sec:challenges},
but has no notion of an
independent, composable ``UI component'' and thus faces challenge \#2.
Thus, achieving modularity
at the level of sub-models and sub-views is entirely up to the
developer.

Shortly after Elm's initial release, Facebook released their web UI
toolkit \textit{React}, which was also based on a variation of the
Model-View-Update paradigm.

React's \texttt{render} function corresponds to Elm's \texttt{view}:
It transforms the model state into a HTML tree.  Unlike Elm,
React has a composable notion of a UI component---a sub-view with its
own associated state.

Where Elm gives the UI program complete freedom in the choice of
\texttt{Model} type, React differentiates two kinds of state:
Immutable \textit{properties} that flow downward in the sub-view tree.
Each component also has its own associated mutable \textit{state},
which needs to be organized as a JavaScript hash map.

Thus, React's model of reactivity is different from Elm's: The UI
program attaches imperative callbacks to UI components, and these
callbacks can either mutate the component state or cause the
properties to be replaced.  Conceptually, React ignores the difference
between these two methods and re-renders the entire UI on each
interaction, just like Elm.  Mutating the state has become
recognized as an anti-pattern in the React community, and updating the
UI now happens in a manner quite similar to Elm.

% FIXME: maybe notes on the implementation

Elm and React represented an erstwhile peak in the evolution of
functional APIs, intellectually hailing from Fudgets and Fruit, and
effectively rendering the functional toolkits that came before them
obsolete: The simplicity of the Model-View-Update paradigm makes it
attractive for a wide spectrum of developers---specifically, it
requires no deeper understanding of higher-level concepts such as
stream transformers, signals, or arrows.  Yet Model-View-Update is
powerful enough to enable even complex applications.  Consequently, we
take Model-View-Update as the starting point for the further
discussion of this paper.

% FIXME: Redux?

\section{UI Toolkits Elsewhere}
\label{sec:ui-toolkits-elsewhere}

\section{Functional Modularity Challenges}
\label{sec:modularity-challenges}

Taking Elm's and React's Model-View-Update pattern as a starting
point, we summarize the architectural tradeoffs listed in
Section~\ref{sec:challenges}:
%
\begin{enumerate}
\item Model-View-Update solves challenge \#1: A single function
  describes view construction, no separate logic for view update is
  needed.
\item Implementing sub-views in a modular fashion remains a challenge:
  A functional Elm/React application essentially manages its model
  state as a single mutable reference at the top level, with
  everything below managed functionally.
\item Movel-View-Update also solves challenge \#3, as the cyclic call
  chain is broken by the succession of models and updates
  presented to the UI toolkit.
\end{enumerate}
%
Solving challenge~\#2 in the context of functional programming
means establishing a notion of ``UI
component'' without resorting to imperative state updates.  A solution
approach needs to address facets described in this section: Updating
the model state in a modular fashion, dealing with UI-local state, and
breaking up global dispatch.

We will illustrate these facets using a simple example: Imagine an
application that manages phone-book entries with name and phone
number.  The application manages the phone book in a functional
manner, as a functional list of immutable entry records.  Its UI
contains a sub-view component that allows viewing and editing a single
name within a text field, along with a ``Submit'' button for actually
changing the phonebook.

% FIXME: maybe a figure

\subsection{Global Model State Update}

When the user changes the name, this is a local change from the point
of view of the UI component, but leads to a global change in the
application, which must update its phonebook reference.  So strictly
speaking, updating the state is not the job of the name UI component
but of all the components above it in the hierarchy that need to
re-construct the state with the one changed name, and finally change
the global reference at the top.

\subsection{UI-Local State}

The model-state update happens when the user clicks the ``Submit''
button.  However, the UI has to manage the contents of the text field
as the user types in the new name one letter at a time.  This
intermediate state is of no interest to the model, hence it is
``UI-local''.  As it is an artifact of the UI widget and not an aspect
of the model, the UI toolkit should enable separting the model state
from the UI-local state.

Note that the classification between model state and UI-local state
depends on context and judgement: The name UI component itself has two
sub-components, a text field and the submit button.  The text field's
model will usually be the visible text.  However, embedded within the
name component, the text field's model state becomes the name
component's UI-local state.

\subsection{Global Dispatch}

In Elm, the UI program communicates requests to change the model state
(as well as other side effects) via messages of type \texttt{Msg},
which the toolkit subsequently passes to the \texttt{update} function.
This \texttt{update} function is global, and thus unmodular.  Making
the global dispatch modular requires associating it with an individual
UI component rather than the program as a whole.

However, a UI component is often not able to handle the messages
generated by user interaction with its view.  Consider again the name UI
component: The name should probably not be empty, and thus the
``Submit'' should be deactivated as long as the text field is empty.
Thus, the text-field component must pass a message upwards to its
enclosing name component, informing it of the state change.
Correspondingly, the enclosing component must be able to handle the
message coming up from its sub-component.

Furthermore, the type of the message produced by the sub-component
must match the type expected by the enclosing component.  This is not
necessarily the case when the two are developed separately: For this
case, the UI toolkit must offer a mechanism to transform the message
along the way from its producer to its handler.

\section{From Model-View-Update to Reacl}
\label{sec:reacl}

FIXME: Temperature example?

As a response to challenges described in the previous section, we
started in 2014 to work on our own UI toolkit for ClojureScript,
\textit{Reacl}~\cite{Reacl}.  This section describes how Reacl tackles
the modularity challenges, using the phonebook example.  Reacl evolved
significantly over its lifetime, eventually leading to its successor
reacl-c described in Section~\ref{sec:reacl-c}.  We describe Reacl version 2
from about 2019.

The phonebook example starts with a namespace declaration that imports
both Reacl and the record library from \textit{Active
  Data}~\cite{ActiveData}, a library for making data modeling
explicit in Clojure(Script):
%
\begin{verbatim}
(ns examples.phonebook.core
  (:require [reacl2.core :as reacl :include-macros true]
            [reacl2.dom :as dom :include-macros true]
            [active.data.record :include-macros true
             :as record
             :refer-macros (def-record)]
            [active.data.realm :as realm]))
\end{verbatim}
%
We use Active Data to declare a record type for an entry in the
phonebook, the central aspect of the model:
%
\begin{verbatim}
(def-record entry
  [entry-id :- realm/integer
   entry-name :- realm/string
   entry-phone-number :- realm/string])
\end{verbatim}
%
In this declaration, \texttt{entry} is the both the record type and
constructor, and \texttt{entry-id} (a unique id identifying the entry
even across name changes), \texttt{entry-name},
\texttt{entry-phone-number} each double as field name and
getter/selector.  The \texttt{realm/} annotations declare the run-time
types of the fields of the record.

We now construct a UI for editing the name of an entry.  To that end,
we start with a reusable component for an editable text field.  This
is implemented via a \textit{class} in Reacl that defines how the
text-field components are rendered and behave:
%
\begin{verbatim}
(def-record change-text
  [change-text-text :- realm/string])

(reacl/defclass text-field
  this text []
  render
  (dom/input {:onchange 
              (fn [e]
                (reacl/send-message!
                 this
                 (change-text
                   change-text-text
                   (.. e -target -value))))
              :value text})
  handle-message
  (fn [msg]
    (cond
      (record/is-a? change-text msg)
      (reacl/return
        :app-state (change-text-text msg)))))
\end{verbatim}
%
In this declaration, \texttt{this} is the name that the code can use
to refer to the current component (similar to \texttt{this} in Java),
and \texttt{text} is the \textit{app state} of the component---its
model.

Two clauses follow, the first of which is \texttt{render}, which
generates the view from the app state \texttt{text}.  This is
straightforward HTML with a callback attached that fires whenever the
user changes the text.  In that case, the callback sends a
message to the component that describes the user's intention,
in this case to change the text in the form of a \texttt{change-text}
record.

Components can send messages to arbitrary other components, but it is
typical to send them ``to themselves,'' as is shown here.  The
\texttt{handle-message} clause defines how a component reacts to a
message it receives.  In this case, the only possible message is a
\texttt{change-text} record, but often components allow for more than
one kind of interaction, which is why there is a \texttt{cond} here that
identifies the \texttt{change-text} record.  The function then calls
\texttt{reacl/return}, which constructs a value that tells Reacl what
to do---in this case replace the app state of the component with the
text from the message, effectively performing an update as in the
Model-View-Update pattern.

In principle, the callback attached to the text field could itself
perform the update---first creating and then dispatching on a message
is more work.  However, this separation of concerns makes the
\texttt{handle-message} function testable, even outside of the running
UI application.  (The \texttt{render} function is also testable by
inspecting the returned HTML, but this comes with caveats described in
Section~\ref{sec:vague-semantics}.)

Next, we create a UI component for actually editing a name from a
phonebook.  The idea is that the phonebook will only be changed when
the user clicks on a \texttt{Submit} button.  Consequently, the app
state of the name component, while it is also a string, will only
change when \texttt{Submit} is pressed.  However, the component still
needs to keep track of current content of the text field.  To that
end, it keeps a \textit{local state}, which is not reflected in the
model state.  The class starts like this:
%
\begin{verbatim}
(reacl/defclass name-editor
  this name []
  local-state [current-name name]
\end{verbatim}
%
Here, \texttt{name} is the app state of the component.  The local
state is called \texttt{current-name} and its initial value upon
creation of the component is \texttt{name}.  Here is the
\texttt{render} clause, which creates an HTML form:
%
\begin{verbatim}
  render
  (dom/form
   {:onsubmit (fn [e]
                (.preventDefault e)
                (reacl/send-message! this (submit)))}
   (dom/div (text-field
             (reacl/opt
               :reaction
               (reacl/reaction
                 this
                 (fn [text]
                   (change-name
                     change-name-text text))))
             current-name)
            (dom/button "Submit")))
\end{verbatim}
%
This calls \texttt{text-field} to create a text-field component,
passing it a \textit{reaction} and \texttt{current-name} as its app
state.  (This shows that one component's app state can be another
component's local state.)  The reaction defines how the
\texttt{name-editor} component reacts to changes in the
\texttt{text-field} component's app state (passed in as \texttt{text}
to the function), typically by sending a message.  Here, the reaction
sends a \texttt{change-name} message to \texttt{this}, defined by the
following record declaration:
%
\begin{verbatim}
(def-record change-name
  [change-name-text :- realm/string])
\end{verbatim}
%
The form callback, which gets called when the user clicks
\texttt{Submit}, sends a singleton \texttt{submit} message as per this
record declaration:
%
\begin{verbatim}
(def-record submit [])
\end{verbatim}
%
Finally, the \texttt{handle-message} function dispatches on the two
messages, updating the local state for \texttt{change-name} and the
app state for \texttt{submit}:
%
\begin{verbatim}
  handle-message
  (fn [msg]
    (cond
      (record/is-a? change-name msg)
      (reacl/return
        :local-state (change-name-text msg))

      (record/is-a? submit msg)
      (reacl/return :app-state current-name))))
\end{verbatim}
%
This example shows how Reacl deals with the three challenges described
in Section~\ref{sec:modularity-challenges}:
%
\begin{description}
\item[Global Model State Update] Each \texttt{handle-message} function
  only describes how to update its own model/app state, with no
  knowledge of and therefore no coupling to the global state of the
  application.
\item[UI-Local State] The \texttt{local-state} mechanism keeps local
  state out of the model.
\item[Global Dispatch] The \texttt{handle-message} function is per
  component class, no global dispatch is necessary.
\end{description}
%
It should be noted that Reacl also has a mechanism not described here
for side effects external to the UI component and global side effects,
such as network
communication.  In order to make the core of the UI application pure,
it creates an \textit{action}, which is similar to a message with the
difference that it does not specify a receiver but gets propagated
upwards in the tree formed by the components until a component either
handles it or transforms it into an action understood further up.
This achieves modularity for actions in a way similar to reactions.

\section{Persistent Pains}
\label{sec:persistent-pains}

User interface construction remains a struggle. In addition to
challenges described above, UI programming -- and testing -- is
considered difficult for reasons that are beyond the grasp of UI
tools.

\subsection{Inherently vague semantics}
\label{sec:vague-semantics}

Many functional user interface frameworks and libraries claim that
they allow users to describe their UI as a pure function from state
(domain model) to a description of a graphical display -- for example
HTML. According to FP folklore, pure functions are easy to
test. Consequently, it should be easy to write UI tests: Run the
function \texttt{f} that is your UI for a sample \texttt{state} of
your domain logic and compare the resulting graphical display
\texttt{(f state)} to your desired version. Even if we forget about
the dynamic nature of UIs for a moment, this approach rarely results
in good tests. Take this temparature display in pseudo-code:
%
\begin{verbatim}
  // a user interface
  let f temp
    = <div
        style={if (tooHot temp)
                 "background: red;"
               else
                 ""}>
       {string_of_temp temp}
      </div>

  // test
  assertEqual (f 22) <div>22</div>
  assertEqual (f 183) <div style="background: red;">183</div>
\end{verbatim}
%
This trivial test already misses the mark. Say we are dissatisfied
with a red background color but we still want to emphasize
temperatures that are too hot. It is reasonable to assume that a red
border is sufficient to fulfill that need. Our test, however, is of a
different opinion. Our test demands backgrounds to be red. In these
situations we have to adapt both our implementation \textit{and} our
tests. This is fine if \textit{these situations} happen rarely. In UI
programming, they happen more often than not.

Tests show their merit under the evolution of implementations. A good
test checks whether an implementation satisfies a given interface,
while allowing for many different implementations. The interface of
most UI components is hard to separate from the implementation,
however. In the example above we want to ensure ``emphasis'', which as
an abstract concept is hard to formalize. Much of what it takes for an
user interface widget to be considered emphasized is out of reach for
its own graphical display: For one, user's habits and expectations
change constantly. A graphical representation that is perfectly
emphatic today might have been overlooked ten years ago. Additionally,
context plays an important role. A graphical representation that is
perfectly emphatic when surrounded by white space appears too timid
surrounded by loud advertisements.

\cite{SPE} suggests a classification of software programs into classes
\textit{S} -- ``programs whose function is formally defined by and
derivable from a specification'' --, \textit{P} -- programs that have
a formal specification, but ``the acceptability of a solution is
determined by the environment in which it is embedded.''  --, and
\textit{E} -- ``programs that mechanize a human or societal
activity''. Classes \textit{P} and \textit{E} are further aggregated
to form the class \textit{A} -- programs ``that represent a computer
application in the real world''. The distinction between \textit{S}
and \textit{A} programs aligns with our distinction between software
aspects that have a precise formal semantics and vague aspects like
\textit{emphasis}. \textit{S} programs are amenable to automated tests
or even formal verification. While it requires effort to write tests
or proofs, running automated tests or checking proofs is
cheap. \textit{A} programs on the other hand require manual tests to
verify their correctness. Running manual tests regularly is expensive
and may be totally infeasible for some software projects.

While most UI software falls into the \textit{A} class \textit{in its
  entirety}, large software is made from smaller parts, which in turn
can be classified as either \textit{S} or \textit{A}. In the
temperature display example above, we already identified
\textit{emphasis} as the problematic aspect in terms of precise formal
semantics -- an \textit{A} aspect. In contrast, the function
\texttt{tooHot} solely operates in terms of the core domain
logic. This function is independent of its context or any human habits
or practices. It belongs to class \textit{S}, and is therefore
amenable to automated tests and verification.

In order to bring down overall costs for tests, we have to strive for
a surgically precise discernment of \textit{S} software parts and
\textit{A} software parts. In other words: We want to write as little
UI code as possible. In the remainder of this work we propose a
discipline that supports this goal: we introduce reacl-c, a UI
combinator library that is optimized for reusability and we make an
argument for the \textit{functional view model}, a UI programming
pattern.

\section{From Reacl to reacl-c}
\label{sec:reacl-c}

Reacl improves on its predecessors in terms of modularity. Modularity
is a neccessary prerequisite for reusability, but it is not
sufficient. Reacl often makes it cumbersome to extract and reify certain
aspects of user interfaces, limiting reusability. This is primarily
due to two reasons.

\begin{enumerate}
  \item Reacl requires early binding of state by default. This means
    that when a user creates a new instance \texttt{C} of a Reacl
    component, they have to decide then and there which other
    component's state \texttt{C}'s state relates to and in which
    way. In most cases, and as you can see in the examples above, the
    ``other component'' is \texttt{this}, which is the conventional
    name for the instance of the component that is being constructed
    at the current moment. This pattern goes a long way. However,
    early binding of state is usually at odds with the creation of
    custom component combinators.
  \item The guideline for dealing with effects in Reacl is to issue
    actions describing the intent. These actions are then handled at
    the top-level. If the action issuer needs a response, it has to
    pack its reference into the action and the action handler has to
    \texttt{send-message!} the response to that reference.
\end{enumerate}

Both of these points were explicit design decisions. These choices
were made under the assumption that UI-specific code makes up a
substantial part of UI software and that these UI-specific parts will
be thoroughly tested. As described in the previous section, we have
since come to the realization that UI code is inherently difficult to
test regardless of any technological choices and our focus should
therefore be in minimizing such parts.

\subsection{User interface combinators}

The ClojureScript library \textit{reacl-c} consists of a set of UI
primitives -- \textit{items} -- and combinators thereof. The library
centers around three namespaces:
%
\begin{verbatim}
(ns example
  (:require [reacl-c.core :as c :include-macros true]
            [reacl-c.main :as main]
            [reacl-c-.dom :as dom]))
\end{verbatim}
%
All items have a notion of state (even though some of them ignore it),
items may have a visual appearance, items may issue actions, and items
may perform effects. Strings are simple items that appear as
themselves on screen, ignore their state, don't issue actions, and
don't perform effects. The \texttt{reacl-c.dom} namespaces provides a
set of simple item combinators corresponding to the DOM elements. The
following example displays an external link, styled with a blue
border.
%
\begin{verbatim}
(dom/a
 {:href "http://example.org"
  :style {:border "1px solid blue"}
 "Link!")
\end{verbatim}
%
All items have state. You can access this state with the
\texttt{dynamic} item constructor, which takes a function that takes
the current state as an argument and returns an item. The resulting
item is the item returned from the function. You can ``set'' state
with the \texttt{isolate-state} item
combinator. \texttt{isolate-state} takes an initial value for the
state and an item. The resulting item is the given item exposed to the
given state. The following item displays ``Hello World'':
%
\begin{verbatim}
(c/isolate-state
 "Hello"
 (c/dynamic (fn [state]
             (str state " World"))
\end{verbatim}
%
Interactivity emanates from event handlers attached to dom items (or
DOM item combinators). The following item implements a simple text input:
%
\begin{verbatim}
(def input
  (c/dynamic
   (fn [text]
    (dom/input
     {:value text
      :onChange
      (fn [old-text event]
        (c/return
         :state
         (.-value
          (.-target event))))}))))
\end{verbatim}
%
In the \texttt{:onClick} handler we signal the intent to update the
current state by returning a special \texttt{return} value. We can
also issue actions with \texttt{(c/return :action ...)}.

Usually we use \texttt{isolate-state}, which completely detaches the
state of items below from the state of items above, very seldomly --
for many applications just once at the top level. Usually we use the
item combinator \texttt{c/focus} to make a child item responsible for
\textit{a part} of the current state. \texttt{focus} takes a lens --
either a function of both arity one (\textit{get}) and of arity two
(\textit{putback}), a Clojure keyword, or a value from the
\texttt{active.clojure.lens} library -- and a child item. The
following example shows a small UI that manages a single entry in a
phone book application.
%
\begin{verbatim}
(def entry
  ;; model: {:name "Name", :tel "123456"}
  (dom/div
   "Name:"
   (c/focus :name input)
   "Tel:"
   (c/focus :tel input)))
\end{verbatim}
%
\texttt{focus} makes for very powerful glue. We can go from this small
item that manages a single phone book entry to an item that manages an
entire phone book just by using \texttt{focus} with a lens from
\texttt{active.clojure.lens}:
%
\begin{verbatim}
(def phone-book
  ;; model: [{:name "Name", :tel "123456"}
  ;;         {:name "Joe", :tel "98765"}]
  (c/dynamic
   (fn [entries]
     (apply
      dom/div
      (map (fn [idx]
             (c/focus
              (lens/at-index idx)
              entry))
           (range
            (count entries)))))))
\end{verbatim}
%
Here we map over the indices of the entries in the phone book and use
\texttt{(c/focus (lens/at-index idx) ...)} to use the \texttt{entry}
item for each phone book entry. This pattern is very common when
dealing with lists. Since the code above only consists of regular
function application and abstraction, we can use lexical extraction
(wie heisst das richtig?) in order to distill this pattern into a
custom combinator:
%
\begin{verbatim}
(defn map-item [child-item]
  (c/dynamic
   (fn [xs]
     (apply
      dom/div
      (map (fn [idx]
             (c/focus
              (lens/at-index idx)
              child-item))
           (range
            (count xs)))))))

(def phone-book-2
  (map-item entry))
\end{verbatim}
%
For a rudimentary phone book application we also want to show a simple
button with a label ``Add new'' that inserts a new entry into the
phone book. This button can directly work with the entire phone book
state:
%
\begin{verbatim}
(def empty-entry
  {:name ""
   :tel ""})

(def phone-book-with-add-button
  (dom/div
   phone-book-2
   (dom/button
    {:onClick
     (fn [phone-book _]
       (c/return
        :state
        (conj phone-book
              empty-entry)))}
    "Add new")))
\end{verbatim}
%
Of course we also want to be able to delete individual entries. We
would like to display one delete button per entry. If we add such a
button to the \texttt{entry} item constructor above, we're lacking the
means to implement the button's functionality directly. We don't have
to refactor our entire application, however. We can have the button
issue an action, signalling our intent to delete a certain entry and
handle the actual deletion further up in the item tree. We build a new
entry item that reuses the old one and attaches a delete button:
%
\begin{verbatim}
(def entry-2
  ;; model: {:name "Name", :tel "123456"}
  (dom/div
   entry
   (dom/button
    {:onClick
     (fn [_ _]
       (c/return :action :delete))}
    "Delete")))
\end{verbatim}
%
Our custom item combinator \texttt{map-item} is no longer fit for
purpose. We can make it more flexible by giving it an extra
argument that describes how actions should be propagated.
%
\begin{verbatim}
(defn map-item-2
  [child-item reduce-action-f]
  (c/dynamic
   (fn [xs]
     (apply
      dom/div
      (map (fn [idx]
             (c/handle-action
              (c/focus
               (lens/at-index idx)
               child-item)
              (fn [_ ac]
                (c/return
                 :action
                 (reduce-action-f idx ac)))))
           (range
            (count xs)))))))
\end{verbatim}
%
Our new phone book item uses this function to enrich the
deletion intent with the information about which index to delete:
%
\begin{verbatim}
(def phone-book-3
  (map-item-2 (entry-2)
              (fn [idx _action]
                [:delete idx])))
\end{verbatim}
%
We can handle actions with the \texttt{c/handle-action} item
combinator. \texttt{c/handle-action} takes an item and a handler
function. Every action that is emitted from the inner item is run
through the handler function, which takes the current state and the
action as arguments. The handler function can return
\texttt{(c/return ...)} values just like an event handler as seen
above. A reasonable place to actually handle deletion is the same
place where we handle additions.
%
\begin{verbatim}
(defn handle-phone-book-actions [phone-book action]
  (assert (vector? action))
  (case (first action)
    :add
    (conj phone-book
          empty-entry)

    :delete
    (remove-entry-at-index
     phone-book
     (second action))))

(def phone-book-with-add-button-2
  (c/handle-action
   (dom/div
    (phone-book-3)
    (dom/button
     {:onClick
      (fn [phone-book _]
        (c/return :action [:add]))}
     "Add new"))
   (fn [phone-book action]
     (c/return
      :state
      (handle-phone-book-actions phone-book action)))))
\end{verbatim}
%


\subsection{The View Model -- functionally}

In the phone book application above, when a user clicks the ``Add
new'' button, we insert a new entry below the others. The user can
then click on the name input field and enter the new entry's name. To
make our application more convenient to use, we want to set keyboard
focus on the name input automatically as soon as the user clicks the
add button. Implementation-wise we might decide to use the browser's
built-in keyboard focus handling with the \texttt{autoFocus}
attribute.

So far the domain model and the state of our items was the same. Now
we also have to keep track of which entry to \texttt{autoFocus}. We
now separate our domain model from the model of our UI state. This
pattern is well-known in the OO community, where it is referred to as
the ``Model-View-ViewModel'' pattern (MVVM). Here we give a brief
introduction of how to use view models functionally.

Our view model includes a phone book entry from the core domain model,
enriched with the information whether this particular entry should be
autofocused. A phone book consists of a sequence of such entries.
%
\begin{verbatim}
(ns view-model
   (require [core]
            ...)

(def-record ^:private entry
  [entry-entry :- core/entry
   entry-autofocus?])

(def-record ^:private phone-book
  [phone-book-entries :- (r/sequence-of entry)])
\end{verbatim}
%
It doesn't make any sense to have more than one \texttt{entry} with
\texttt{entry-autofocus?} set to \texttt{true}. There are many ways to
ensure this constraint. Here we decide to provide a set of smart
constructors and accessors that keep the constraint satisfied. First,
we need the idea of an empty phone book:
%
\begin{verbatim}
(def empty (phone-book phone-book-entries []))
\end{verbatim}
%
We also need a way to add a new entry to the phone book. This is the
place where we set the \texttt{autofocus?} flags:
%
\begin{verbatim}
(defn unfocus [entry]
  (entry-autofocus? entry false))

(defn add-entry [phone-book core-entry]
  (lens/overhaul phone-book phone-book-entries
                 (fn [entries]
                   (conj (mapv unfocus entries)
                         (entry-vm entry-entry core-entry
                                   entry-autofocus? true)))))
\end{verbatim}
%
And we need a function to delete entries:
%
\begin{verbatim}
(defn delete-entry-at-index [phone-book idx]
  (lens/overhaul phone-book
                 phone-book-entries
                 remove-entry-at-index
                 idx))
\end{verbatim}
%
TODO: new names for lenses above (e.g. phone-book-entry-at-index)
%
This concludes the (view) modelling part. The corresponding UI code is
very similar to the code above. First, we have to parameterize the
input item with an autofocus flag.
%
\begin{verbatim}
(defn input [autofocus?]
  (c/dynamic
   (fn [text]
    (dom/input
     {:autoFocus autofocus?
      :value text
      :onChange
      (fn [old-text event]
        (c/return
         :state
         (.-value
          (.-target event))))}))))
\end{verbatim}
%
The new entry item now has to handle focus as well.
%
\begin{verbatim}
(defn entry [autofocus?]
  (dom/div
   "Name:"
   (c/focus core-entry-name (input autofocus?))
   "Tel:"
   (c/focus core-entry-tel (input false))))
\end{verbatim}
%
The outer entry item -- the one that adds a delete button -- now has to use the new \texttt{entry*}:
%
\begin{verbatim}
(def entry-2
  ;; model: entry-vm
  (c/dynamic
   (fn [entry-vm]
     (dom/div
      (c/focus entry-entry
               (entry
                (entry-autofocus? entry-vm)))
      (dom/button
       {:onClick
        (fn [_ _]
          (c/return :action :delete))}
       "Delete")))))
\end{verbatim}
%
The rest of the code stays exactly the same.


\section{Conclusion}
\label{sec:conclusion}

FIXME

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{funarch-ui}

\end{document}
\endinput
%%
% TODOs:
% - cite Conal


